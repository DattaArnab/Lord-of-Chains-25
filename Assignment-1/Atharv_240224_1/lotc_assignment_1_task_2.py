# -*- coding: utf-8 -*-
"""LOTC_Assignment_1_task_2ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q9Zb2PUYPmL_1hDkcuPvfqodQL_-WFDA
"""

import random
from typing import List, Dict

class Node:
    """
    Represents a node in the Avalanche network with a binary state (0 or 1).
    Manages Slush (sampling), Snowflake (consecutive counts), and Snowball (preference).
    """
    def __init__(self, name: str, initial_state: int):
        """Initialize node with name and random initial state."""
        self.name = name
        self.state = initial_state  # 0 (reject) or 1 (accept)
        self.snowflake_count = 0  # Snowflake: Consecutive same-state samples
        self.snowball_counter = {0: 0, 1: 0}  # Snowball: Consecutive state counts
        self.preferred_state = initial_state  # Snowball: Preferred state
        self.confident = False  # Snowflake: Confidence flag

    def sample_peers(self, all_nodes: List['Node'], k: int, alpha: int) -> int:
        """
        Slush phase: Sample k random peers and return majority state.
        Requires at least alpha peers to agree for majority.
        """
        peers = [n for n in all_nodes if n != self]
        if len(peers) < k:
            raise ValueError(f"Not enough peers to sample {k} nodes")
        sample = random.sample(peers, k)
        states = [node.state for node in sample]
        count_1 = states.count(1)
        majority_state = 1 if count_1 >= alpha else 0
        print(f"{self.name} sampled {k} nodes: {[n.name for n in sample]}, states: {states}, majority: {majority_state} (1's: {count_1}, alpha: {alpha})")
        return majority_state

    def update_state(self, sampled_state: int, beta: int):
        """
        Update state through Snowflake and Snowball phases.
        Snowflake: Track consecutive samples, become confident after beta matches.
        Snowball: Update preferred state based on consecutive counts.
        """
        # Snowflake: Update consecutive count
        if sampled_state == self.state:
            self.snowflake_count += 1
        else:
            self.snowflake_count = 1
            self.state = sampled_state  # Slush: Adopt majority state
        self.snowball_counter[sampled_state] += 1
        self.snowball_counter[1 - sampled_state] = 0  # Reset other state

        # Snowflake: Gain confidence after beta consecutive samples
        if self.snowflake_count >= beta and not self.confident:
            self.confident = True
            print(f"{self.name} is confident in state {self.state} after {beta} consecutive samples")

        # Snowball: Update preferred state if current state has higher count
        if self.snowball_counter[sampled_state] > self.snowball_counter[self.preferred_state]:
            self.preferred_state = sampled_state
            print(f"{self.name} updated preferred state to {self.preferred_state}")

class AvalancheNetwork:
    """
    Simulates Avalanche consensus with multiple nodes.
    Parameters:
    - node_names: List of node names
    - k: Sample size per query
    - alpha: Quorum threshold for majority in Slush
    - beta: Consecutive sample threshold for Snowflake
    - max_rounds: Maximum number of rounds
    """
    def __init__(self, node_names: List[str], k: int, alpha: int, beta: int, max_rounds: int):
        """Initialize network with nodes and parameters."""
        self.nodes = [Node(name, random.choice([0, 1])) for name in node_names]
        self.k = k
        self.alpha = alpha
        self.beta = beta
        self.max_rounds = max_rounds
        self.consensus_rounds = 0  # Track rounds of full agreement

    def run_simulation(self) -> tuple[int, int]:
        """
        Run Avalanche consensus until all nodes agree for two rounds or max_rounds reached.
        Returns (final_state, rounds_taken).
        """
        print("Starting Avalanche consensus simulation for transaction validity (0=reject, 1=accept)")
        for round_num in range(1, self.max_rounds + 1):
            print(f"\nRound {round_num}:")
            # Display current states
            states = {node.name: node.state for node in self.nodes}
            print(f"Node states: {states}")

            # Each node samples and updates state
            for node in self.nodes:
                try:
                    sampled_state = node.sample_peers(self.nodes, self.k, self.alpha)
                    node.update_state(sampled_state, self.beta)
                except ValueError as e:
                    print(f"Error for {node.name}: {e}")
                    return None, round_num

            # Avalanche: Check for network-wide agreement
            current_states = [node.state for node in self.nodes]
            if len(set(current_states)) == 1:
                self.consensus_rounds += 1
                print(f"All nodes agree on state {current_states[0]}")
                if self.consensus_rounds >= 2:
                    print(f"\nConsensus achieved: Transaction is {'accepted' if current_states[0] == 1 else 'rejected'}")
                    return current_states[0], round_num
            else:
                self.consensus_rounds = 0  # Reset if not all agree

        print("\nNo consensus reached within max rounds")
        return None, self.max_rounds

def main():
    """Main function to run the Avalanche simulation with user input."""
    # Default node names
    default_nodes = [
        "Amit", "Priya", "Rahul", "Neha", "Vikram",
        "Anjali", "Rohit", "Sneha", "Karan", "Deepika"
    ]

    try:
        num_nodes = int(input("Enter number of nodes (default 10): ") or 10)
        if num_nodes < 2:
            raise ValueError("Number of nodes must be at least 2")
        k = int(input("Enter sample size k (default 5): ") or 5)
        if k < 1:
            raise ValueError("Sample size must be at least 1")
        alpha = int(input("Enter quorum threshold alpha (default 3): ") or 3)
        if alpha < 1 or alpha > k:
            raise ValueError("Alpha must be between 1 and k")
        beta = int(input("Enter Snowflake threshold beta (default 3): ") or 3)
        if beta < 1:
            raise ValueError("Beta must be at least 1")
        max_rounds = int(input("Enter max rounds (default 100): ") or 100)
        if max_rounds < 1:
            raise ValueError("Max rounds must be at least 1")
    except ValueError as e:
        print(f"Invalid input: {e}")
        return

    # Select node names
    node_names = default_nodes[:num_nodes] if num_nodes <= len(default_nodes) else \
                 [f"Node{i+1}" for i in range(num_nodes)]

    # Run simulation
    network = AvalancheNetwork(node_names, k, alpha, beta, max_rounds)
    final_state, rounds_taken = network.run_simulation()

    # Display results
    print(f"\nSimulation completed in {rounds_taken} rounds")
    if final_state is not None:
        print(f"Final state: Transaction is {'accepted' if final_state == 1 else 'rejected'}")
        final_states = [node.state for node in network.nodes]
        print(f"State 0 count: {final_states.count(0)}")
        print(f"State 1 count: {final_states.count(1)}")
    else:
        print("No consensus reached")
        final_states = [node.state for node in network.nodes]
        print(f"Final states: { {node.name: node.state for node in network.nodes} }")

if __name__ == "__main__":
    main()